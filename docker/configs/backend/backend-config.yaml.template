backend:
  # The log level can be one of debug, info, warn and error.
  # https://pkg.go.dev/log/slog#Level
  log_level: debug
  log_file: /app/logs/backend.log
  downloader:
    # Location where downloaded malware will be stored.
    malware_download_dir: /app/malware/
    # The malware downloaded HTTP client timeout. This should be relatively high
    # because sometimes malware is served from very slow IoT devices.
    http_timeout: 10m
  listener:
    # IP and port where the backend needs to listen on.
    listen_address: 0.0.0.0:41110
    ssl_cert: /app/certs/backend/server-cert.pem
    ssl_key: /app/certs/backend/server-key.pem
    ssl_ca_cert: /app/certs/ca/ca-cert.pem

  database:
    # URL to the postgresql database
    url: postgres://lo:%%DB_PASSWORD%%@postgres:5432/postgres
    # How many open concurrent database connections are allowed.
    max_open_connections: 30
    # How many connections to keep open all the time.
    min_open_connections: 10
  advanced:
    # Debug IPs will get the session ID and request ID send back via headers in
    # the response. This makes debugging easier.
    debug_ips:
      - 192.168.50.0/24
    # How long to cache Content's that were fetched from the database.
    content_cache_duration: 30m
    # How long to cache download URLs which prevents them from being fetched
    # again if seen multiple times in a row during this time. Don't set this
    # too long because attacker payloads change over time and it's interesting
    # to track this by refetching the same payload URLs.
    download_cache_duration: 5m
    ping_cache_duration: 1m
    # How long before sessions expire after receiving the last request. New
    # requests reset the timeout.
    session_tracking_timeout: 15m
    honeypot_default_content_id: 77
  ratelimiter:
    rate_window: 1h
    bucket_duration: 1m
    max_ip_requests_per_window: 1500
    max_ip_requests_per_bucket: 300
    max_uri_requests_per_window: 8000
    max_uri_requests_per_bucket: 800


analysis:
  # Determines how long information for an IP will be cached before
  # writing it to the database. During that time the information will be
  # updated with new events if they happen.
  ip_cache_duration: 15m
  # How many events there can be in the queue. If this is exceeded then it
  # will start blocking some logic in the backend so keep this number high
  # and monitor the queue size with prometheus/grafana.
  ip_event_queue_size: 5000
  # Determines how long (approximately) the scan detection logic will keep
  # aggregating scan events into a cached version before writing it to the db.
  # So with the default below, if there is a super slow scan, you will
  # get an event every ~1 hour.
  scan_monitor_interval: 1h

#alerting:
#  web_interface_address: https://changeme_in_config:62211
#  # The alerting interval.  Alerts are aggregated and send every <interval>.
#  interval: 2m
#  telegram:
#    # Telegram API key and channel ID.
#    api_key: xxxxxx
#    channel_id: 11223344

virustotal:
  # Your virus total API key.
  api_key: %%VIRUSTOTAL_API_KEY%%
  # HTTP timeout for communication with virustotal.
  http_timeout: 2m

scripting:
  allowed_commands:
    - /usr/bin/false
    - /usr/bin/echo

prometheus:
  listen_address: 0.0.0.0:8998

whois_manager:
  client_timeout: 2s
  cache_expiration_time: 12h
  max_attempts: 6

yara:
  log_file: /tmp/yara.log
  log_level: debug
  metrics_listen_address: 0.0.0.0:8997
  prepare_command: scripts/yaraPrepareCommand.sh

ai:
  # Named LLM configurations that can be referenced by other settings.
  # This avoids duplicating LLM config across multiple features.
  llm_configs:
    # Large model for complex tasks like responder and describer
    - name: qwen_large
      config:
        cache_expiration_time: 100h
        completion_timeout: 60s
        concurrent_requests: 20
        primary_llm:
          api_location: https://openrouter.ai/api/v1
          model: qwen/qwen3-235b-a22b-2507
          api_key: %%OPENROUTER_API_KEY%%

    # Fast model for shell emulation and preprocessing
    - name: gemini_flash
      config:
        cache_expiration_time: 1h
        completion_timeout: 60s
        concurrent_requests: 5
        primary_llm:
          api_location: https://openrouter.ai/api/v1
          model: google/gemini-2.5-flash-lite
          api_key: %%OPENROUTER_API_KEY%%

    # Code-focused model for code/file/sql emulation
    - name: qwen_coder
      config:
        cache_expiration_time: 1h
        completion_timeout: 60s
        concurrent_requests: 5
        primary_llm:
          api_location: https://openrouter.ai/api/v1
          model: qwen/qwen3-coder-30b-a3b-instruct
          api_key: %%OPENROUTER_API_KEY%%

  llm_responder:
    enable: 1
    llm_config: qwen_large

  shell_emulation:
    enable: 1
    llm_config: gemini_flash

  code_emulation:
    enable: 1
    llm_config: qwen_coder

  file_emulation:
    enable: 1
    llm_config: qwen_coder

  sql_emulation:
    enable: 1
    llm_config: qwen_coder

  triage:
    describer:
      enable: 1
      llm_config: gemini_flash
      log_file: /app/logs/triage.log
      log_level: debug
      metrics_listen_address: 0.0.0.0:8999
      cache_expiration_time: 8h

    preprocess:
      llm_config: gemini_flash
